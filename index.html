<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Tesla Ladeplan med Solmøller</title>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
    }
    
    body {
        background: #f5f5f7;
        font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', Arial, sans-serif;
        color: #1d1d1f;
        min-height: 100vh;
        padding: 12px;
        overflow-x: hidden;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }
    
    .container {
        max-width: 100%;
        width: 450px;
        margin: 0 auto;
        background: white;
        border-radius: 16px;
        padding: 16px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        border: 1px solid #e5e5e7;
    }
    
    @media (max-width: 480px) {
        body {
            padding: 8px;
        }
        
        .container {
            width: 100%;
            padding: 14px;
            border-radius: 12px;
        }
    }
    
    .time-selector {
        display: flex;
        background: #f2f2f7;
        border-radius: 12px;
        padding: 3px;
        margin-bottom: 16px;
        overflow-x: auto;
        scrollbar-width: none;
        -ms-overflow-style: none;
    }
    
    .time-selector::-webkit-scrollbar {
        display: none;
    }
    
    .time-option {
        flex: 1;
        min-width: 55px;
        text-align: center;
        padding: 8px 12px;
        border-radius: 9px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
        color: #86868b;
        white-space: nowrap;
    }
    
    .time-option:active {
        transform: scale(0.96);
    }
    
    .time-option.active {
        background: white;
        color: #1d1d1f;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    .chart-container {
        height: 140px;
        margin-bottom: 16px;
        position: relative;
        background: #fafafa;
        border-radius: 12px;
        padding: 16px 12px 8px 12px;
        border: 1px solid #e5e5e7;
    }
    
    .empty-state {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 24px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #86868b;
    }
    
    .empty-state .main-message {
        font-size: 16px;
        font-weight: 600;
        color: #1d1d1f;
        margin-bottom: 8px;
    }
    
    .empty-state .sub-message {
        font-size: 12px;
        color: #86868b;
        text-align: center;
        line-height: 1.4;
    }
    
    .chart {
        display: flex;
        align-items: end;
        height: 100px;
        padding: 0;
        gap: 3px;
        position: relative;
    }
    
    .bar {
        flex: 1;
        border-radius: 3px 3px 0 0;
        transition: all 0.2s ease;
        position: relative;
        cursor: pointer;
        min-height: 4px;
    }
    
    .bar:hover {
        transform: translateY(-1px);
        filter: brightness(0.9);
    }
    
    .bar:active {
        transform: translateY(0px);
    }
    
    .bar.touch-active {
        transform: translateY(-1px);
        filter: brightness(0.9);
    }
    
    .bar.charging {
        background: repeating-linear-gradient(
            45deg,
            #ffffff,
            #ffffff 3px,
            rgba(48, 209, 88, 0.7) 3px,
            rgba(48, 209, 88, 0.7) 6px
        );
        box-shadow: 0 0 8px rgba(48, 209, 88, 0.4);
        border: 1px solid rgba(48, 209, 88, 0.8);
        animation: charging-pulse 2s infinite;
    }
    
    .bar.charging.past {
        background: repeating-linear-gradient(
            45deg,
            #f0f0f0,
            #f0f0f0 3px,
            rgba(36, 138, 61, 0.4) 3px,
            rgba(36, 138, 61, 0.4) 6px
        );
        opacity: 0.6;
        animation: none;
    }
    
    .bar.current-time {
        background: #9370DB;
    }
    
    .bar.green { background: #30d158; }
    .bar.green.past { background: #248a3d; opacity: 0.6; }
    
    .bar.orange { background: #ff9500; }
    .bar.orange.past { background: #cc7700; opacity: 0.6; }
    
    .bar.red { background: #ff3b30; }
    .bar.red.past { background: #cc2e26; opacity: 0.6; }
    
    .bar.purple { background: #af52de; }
    .bar.purple.past { background: #8c42b1; opacity: 0.6; }
    
    .time-labels {
        display: flex;
        justify-content: space-between;
        margin-top: 8px;
        font-size: 11px;
        color: #86868b;
        padding: 0 2px;
        font-weight: 500;
    }
    
    .tooltip-portal {
        position: fixed;
        background: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 11px;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        z-index: 10000;
        top: 0;
        left: 0;
        backdrop-filter: blur(10px);
    }
    
    .tooltip-portal.visible {
        opacity: 1;
    }
    
    .data-source {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        font-size: 10px;
        color: #86868b;
        margin-bottom: 12px;
        padding: 4px 8px;
        background: #f8f8f8;
        border-radius: 6px;
        border: 1px solid #e8e8e8;
    }
    
    .reliability-indicator {
        font-size: 12px;
        font-weight: bold;
    }
    
    .summary-card {
        background: #f2f2f7;
        border-radius: 12px;
        padding: 6px 16px;
        border: 1px solid #e5e5e7;
        text-align: center;
        min-height: auto;
        line-height: 1.2;
    }
    
    .summary-title {
        font-size: 11px;
        color: #86868b;
        margin-bottom: 4px;
        font-weight: 500;
        line-height: 1.1;
    }
    
    .summary-price {
        font-size: 13px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        color: #1d1d1f;
        line-height: 1.1;
    }
    
    .summary-divider {
        color: #86868b;
        font-weight: 400;
    }
    
    .charging-start {
        font-size: 11px;
        color: #86868b;
        margin-top: 6px;
        font-weight: 500;
        line-height: 1.1;
    }
    
    @keyframes charging-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.8; }
    }
    
    @media (prefers-reduced-motion: reduce) {
        * {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }
</style>
</head>
<body>
    <div class="container">
        <div class="time-selector">
            <div class="time-option active" onclick="switchDay('today')">I dag</div>
        </div>

        <div class="chart-container">
            <div class="chart" id="priceChart"></div>
            <div class="time-labels">
                <span>00</span>
                <span>06</span>
                <span>12</span>
                <span>18</span>
                <span>24</span>
            </div>
        </div>
        
        <div class="data-source">
            <span id="dataSource">Tesla data</span>
            <span id="reliability" class="reliability-indicator">●</span>
        </div>
        
        <div class="summary-card">
            <div class="summary-title">Ladeinfo</div>
            <div class="summary-price">
                <span id="kWhNeeded">0 kWh</span>
                <span class="summary-divider">|</span>
                <span id="totalCost">0 kr</span>
            </div>
            <div class="charging-start" id="chargingStart">
                Ladning ikke planlagt
            </div>
        </div>
    </div>

    <div id="tooltipPortal" class="tooltip-portal"></div>

<script>
    // Global state
    let currentDay = 'today';
    let currentTeslaData = null;
    let refreshTimer = null;
    let isPageVisible = true;
    let hasLiveTeslaData = false;

    const CONFIG = {
        refreshInterval: 60000,
        retryAttempts: 3,
        retryDelay: 2000,
        dataURL: 'https://gist.githubusercontent.com/boellehuus/ac3fe4331b033d941cdc836936d4c3c9/raw/elbil-data.json',
        exchangeRateURL: 'https://www.nationalbanken.dk/api/currencyrates',
        exchangeRateFallbackURL: 'https://api.exchangerate-api.com/v4/latest/EUR',
        cachedEURRate: 7.44,
        lastRateUpdate: null,
        solmollerURL: 'https://raw.githubusercontent.com/solmoller/Spotprisprognose/main/prognose.json',
        solmollerArea: 'DK1',
        billigkwhURL: 'https://billigkwh.dk/api/Priser/HentPriser?sted=DK1&netselskab=vores_elnet&produkt=greenbow_elaftale'
    };

    const priceDataSet = {
        today: [],
        tomorrow: []
    };

    const henrikDataSet = {
        today: [],
        tomorrow: [],
        day2: [],
        day3: [],
        day4: [],
        day5: [],
        day6: []
    };

    const billigkwhDataSet = {
        today: [],
        tomorrow: []
    };

    const chargingSchedule = {
        today: [],
        tomorrow: [],
        day2: [],
        day3: [],
        day4: [],
        day5: [],
        day6: []
    };

    let priceData = [];

    const defaultTariffComponents = {
        elafgift: 0.697,
        nettarif: 0.65,
        systemtarif: 0.12,
        spottillaeg: 0.05,
        momsRate: 1.25
    };

    let calibratedTariffComponents = null;

    // Exchange rate functions
    function loadCachedRate() {
        try {
            const cached = localStorage.getItem('eurRate');
            const timestamp = localStorage.getItem('rateTimestamp');
            
            if (cached && timestamp) {
                const age = Date.now() - parseInt(timestamp);
                if (age < 24 * 60 * 60 * 1000) {
                    CONFIG.cachedEURRate = parseFloat(cached);
                    CONFIG.lastRateUpdate = new Date(parseInt(timestamp));
                    console.log('Loaded cached EUR rate:', CONFIG.cachedEURRate);
                    return true;
                }
            }
        } catch (error) {
            console.warn('Could not load cached rate:', error);
        }
        return false;
    }

    async function fetchExchangeRate() {
        try {
            const now = new Date();
            const lastUpdate = CONFIG.lastRateUpdate;
            
            if (lastUpdate && (now - lastUpdate) < 24 * 60 * 60 * 1000) {
                return CONFIG.cachedEURRate;
            }
            
            console.log('Fetching new EUR/DKK rate...');
            
            let eurRate = null;
            
            try {
                const response = await fetch(CONFIG.exchangeRateURL);
                if (response.ok) {
                    const rates = await response.json();
                    const eurRateObj = rates.find(rate => rate.currency === 'EUR');
                    if (eurRateObj && eurRateObj.rate) {
                        eurRate = eurRateObj.rate;
                        console.log('EUR/DKK from Nationalbank:', eurRate);
                    }
                }
            } catch (error) {
                console.log('Nationalbank failed, trying fallback...');
            }
            
            if (!eurRate) {
                try {
                    const response = await fetch(CONFIG.exchangeRateFallbackURL);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.rates && data.rates.DKK) {
                            eurRate = data.rates.DKK;
                            console.log('EUR/DKK from fallback:', eurRate);
                        }
                    }
                } catch (error) {
                    console.warn('Fallback API failed:', error);
                }
            }
            
            if (eurRate && eurRate > 6 && eurRate < 9) {
                CONFIG.cachedEURRate = eurRate;
                CONFIG.lastRateUpdate = now;
                
                localStorage.setItem('eurRate', eurRate.toString());
                localStorage.setItem('rateTimestamp', now.getTime().toString());
                
                console.log('EUR/DKK rate updated and cached:', eurRate);
            } else {
                console.warn('Invalid rate received, using cached:', CONFIG.cachedEURRate);
            }
            
            return CONFIG.cachedEURRate;
            
        } catch (error) {
            console.warn('Could not fetch exchange rate, using cached:', CONFIG.cachedEURRate);
            return CONFIG.cachedEURRate;
        }
    }

    // Henrik data functions
    async function fetchSolmollerData() {
        try {
            console.log('Fetching Henrik Solmoller 7-day forecast...');
            
            const response = await fetch(CONFIG.solmollerURL + '?t=' + Date.now());
            
            if (!response.ok) {
                throw new Error(`Henrik API HTTP ${response.status}`);
            }
            
            const henrikData = await response.json();
            console.log('Henrik data received');
            console.log('Forecast created:', henrikData["Forecast created"]);
            
            updateHenrikDataSet(henrikData);
            
            return henrikData;
            
        } catch (error) {
            console.warn('Henrik data fetch failed:', error);
            Object.keys(henrikDataSet).forEach(day => henrikDataSet[day] = []);
            return null;
        }
    }

    function updateHenrikDataSet(henrikData) {
        try {
            console.log('Organizing Henrik data into 7-day structure...');
            
            Object.keys(henrikDataSet).forEach(day => henrikDataSet[day] = []);
            
            if (!henrikData || !henrikData.DK1) {
                console.warn('Invalid Henrik data format - missing DK1 data');
                return;
            }
            
            const now = new Date();
            const copenhagenNow = new Date(now.toLocaleString("en-US", {timeZone: "Europe/Copenhagen"}));
            const copenhagenToday = new Date(copenhagenNow.getFullYear(), copenhagenNow.getMonth(), copenhagenNow.getDate());
            
            const areaData = henrikData[CONFIG.solmollerArea] || henrikData.DK1;
            
            console.log(`Processing ${CONFIG.solmollerArea} data:`, areaData.length, 'entries');
            
            areaData.forEach(entry => {
                try {
                    const utcDate = new Date(entry.Time + 'Z');
                    const copenhagenDate = new Date(utcDate.toLocaleString("en-US", {timeZone: "Europe/Copenhagen"}));
                    const copenhagenHour = copenhagenDate.getHours();
                    const price = parseFloat(entry.Price);
                    
                    const copenhagenDay = new Date(copenhagenDate.getFullYear(), copenhagenDate.getMonth(), copenhagenDate.getDate());
                    const daysDiff = Math.floor((copenhagenDay - copenhagenToday) / (24 * 60 * 60 * 1000));
                    
                    let targetDay = null;
                    if (daysDiff === 0) targetDay = 'today';
                    else if (daysDiff === 1) targetDay = 'tomorrow';
                    else if (daysDiff === 2) targetDay = 'day2';
                    else if (daysDiff === 3) targetDay = 'day3';
                    else if (daysDiff === 4) targetDay = 'day4';
                    else if (daysDiff === 5) targetDay = 'day5';
                    else if (daysDiff === 6) targetDay = 'day6';
                    
                    if (targetDay && copenhagenHour >= 0 && copenhagenHour <= 23) {
                        if (henrikDataSet[targetDay].length === 0) {
                            henrikDataSet[targetDay] = new Array(24).fill(0);
                        }
                        henrikDataSet[targetDay][copenhagenHour] = price;
                    }
                    
                } catch (parseError) {
                    console.warn('Could not parse Henrik entry:', parseError, entry);
                }
            });
            
        } catch (error) {
            console.error('Error organizing Henrik data:', error);
        }
    }

    function hasHenrikDataForDay(day) {
        return henrikDataSet[day] && 
               Array.isArray(henrikDataSet[day]) && 
               henrikDataSet[day].length === 24 &&
               henrikDataSet[day].some(price => price > 0);
    }

    // BilligkWh functions
    async function fetchBilligkWhData() {
        try {
            console.log('Fetching BilligkWh prices...');
            
            const response = await fetch(CONFIG.billigkwhURL + '&t=' + Date.now(), {
                headers: {
                    'User-Agent': 'Tesla-Dashboard/1.0'
                }
            });
            
            if (!response.ok) {
                throw new Error(`BilligkWh API HTTP ${response.status}`);
            }
            
            const billigkwhData = await response.json();
            console.log('BilligkWh data received');
            
            updateBilligkWhDataSet(billigkwhData);
            
            return billigkwhData;
            
        } catch (error) {
            console.warn('BilligkWh data fetch failed:', error);
            Object.keys(billigkwhDataSet).forEach(day => billigkwhDataSet[day] = []);
            return null;
        }
    }

    function updateBilligkWhDataSet(billigkwhData) {
        try {
            console.log('Organizing BilligkWh data...');
            
            Object.keys(billigkwhDataSet).forEach(day => billigkwhDataSet[day] = []);
            
            if (!billigkwhData || !Array.isArray(billigkwhData)) {
                console.warn('Invalid BilligkWh data format');
                return;
            }
            
            const now = new Date();
            const copenhagenNow = new Date(now.toLocaleString("en-US", {timeZone: "Europe/Copenhagen"}));
            const copenhagenToday = new Date(copenhagenNow.getFullYear(), copenhagenNow.getMonth(), copenhagenNow.getDate());
            
            billigkwhData.forEach((dayData, index) => {
                try {
                    if (!dayData.dato || !dayData.priser || !Array.isArray(dayData.priser)) {
                        return;
                    }
                    
                    const billigkwhDate = new Date(dayData.dato);
                    const billigkwhDay = new Date(billigkwhDate.getFullYear(), billigkwhDate.getMonth(), billigkwhDate.getDate());
                    
                    const daysDiff = Math.floor((billigkwhDay - copenhagenToday) / (24 * 60 * 60 * 1000));
                    
                    let targetDay = null;
                    if (daysDiff === 0) targetDay = 'today';
                    else if (daysDiff === 1) targetDay = 'tomorrow';
                    
                    if (targetDay && dayData.priser.length === 24) {
                        billigkwhDataSet[targetDay] = [...dayData.priser];
                        
                        const avgPrice = dayData.priser.reduce((sum, p) => sum + p, 0) / 24;
                        console.log(`BilligkWh ${targetDay}: avg ${avgPrice.toFixed(3)} kr/kWh`);
                    }
                    
                } catch (parseError) {
                    console.warn('Could not parse BilligkWh day:', parseError);
                }
            });
            
        } catch (error) {
            console.error('Error organizing BilligkWh data:', error);
        }
    }

    function hasBilligkWhDataForDay(day) {
        return billigkwhDataSet[day] && 
               Array.isArray(billigkwhDataSet[day]) && 
               billigkwhDataSet[day].length === 24 &&
               billigkwhDataSet[day].some(price => price > 0);
    }

    // Price enhancement functions
    function calculateActualMissingComponents(teslaData, henrikData, eurRate, billigkwhData = null) {
        try {
            console.log('Calibrating tariffs...');
            
            if (billigkwhData && hasBilligkWhDataForDay('today')) {
                console.log('Using BilligkWh for calibration');
                return calibrateAgainstBilligkWh(henrikData, eurRate, billigkwhData);
            }
            
            const teslaTomorrow = teslaData.Elbil_price_data_tomorrow;
            const henrikTomorrow = henrikDataSet.tomorrow;
            
            if (!teslaTomorrow || !henrikTomorrow || 
                teslaTomorrow.length !== 24 || henrikTomorrow.length !== 24) {
                console.log('Insufficient overlapping data for Tesla calibration');
                return null;
            }
            
            console.log('Using Tesla data for calibration');
            return calibrateAgainstTesla(teslaTomorrow, henrikTomorrow, eurRate);
            
        } catch (error) {
            console.error('Calibration failed:', error);
            return null;
        }
    }

    function calibrateAgainstBilligkWh(henrikData, eurRate, billigkwhData) {
        try {
            const henrikToday = henrikDataSet.today;
            const billigkwhToday = billigkwhDataSet.today;
            
            if (!henrikToday || !billigkwhToday || 
                henrikToday.length !== 24 || billigkwhToday.length !== 24) {
                console.log('Insufficient BilligkWh overlapping data');
                return null;
            }
            
            console.log('Calibrating Henrik vs BilligkWh for today...');
            
            const henrikSpotPrices = henrikToday.map(eurPerMWh => 
                (eurPerMWh / 1000) * eurRate
            );
            
            const missingComponents = [];
            
            for (let hour = 0; hour < 24; hour++) {
                const billigkwhCompletePrice = billigkwhToday[hour];
                const henrikSpotPrice = henrikSpotPrices[hour];
                const missing = billigkwhCompletePrice - henrikSpotPrice;
                missingComponents.push(missing);
            }
            
            const avgMissing = missingComponents.reduce((sum, c) => sum + c, 0) / missingComponents.length;
            
            console.log('BilligkWh Calibration Results:');
            console.log(`Average missing components: ${avgMissing.toFixed(3)} kr/kWh`);
            
            const calibrated = {
                elafgift: 0.697,
                variableTariffs: Math.max(0, avgMissing - 0.697),
                momsIncluded: true,
                avgMissing: avgMissing,
                reliability: 'high',
                calibrationSource: 'BilligkWh'
            };
            
            calibrated.nettarif = calibrated.variableTariffs * 0.75;
            calibrated.systemtarif = calibrated.variableTariffs * 0.15;
            calibrated.spottillaeg = calibrated.variableTariffs * 0.10;
            calibrated.momsRate = 1.0;
            
            return calibrated;
            
        } catch (error) {
            console.error('BilligkWh calibration failed:', error);
            return null;
        }
    }

    function calibrateAgainstTesla(teslaTomorrow, henrikTomorrow, eurRate) {
        try {
            console.log('Calibrating Henrik vs Tesla for tomorrow...');
            
            const henrikSpotPrices = henrikTomorrow.map(eurPerMWh => 
                (eurPerMWh / 1000) * eurRate
            );
            
            const missingComponents = [];
            
            for (let hour = 0; hour < 24; hour++) {
                const teslaCompletePrice = teslaTomorrow[hour];
                const henrikSpotPrice = henrikSpotPrices[hour];
                const missing = teslaCompletePrice - henrikSpotPrice;
                missingComponents.push(missing);
            }
            
            const avgMissing = missingComponents.reduce((sum, c) => sum + c, 0) / missingComponents.length;
            
            console.log('Tesla Calibration Results:');
            console.log(`Average missing components: ${avgMissing.toFixed(3)} kr/kWh`);
            
            const calibrated = {
                elafgift: 0.697,
                variableTariffs: Math.max(0, avgMissing - 0.697),
                momsIncluded: true,
                avgMissing: avgMissing,
                reliability: 'high',
                calibrationSource: 'Tesla'
            };
            
            calibrated.nettarif = calibrated.variableTariffs * 0.75;
            calibrated.systemtarif = calibrated.variableTariffs * 0.15;
            calibrated.spottillaeg = calibrated.variableTariffs * 0.10;
            calibrated.momsRate = 1.0;
            
            return calibrated;
            
        } catch (error) {
            console.error('Tesla calibration failed:', error);
            return null;
        }
    }

    function getTariffComponents() {
        if (calibratedTariffComponents && calibratedTariffComponents.reliability === 'high') {
            return calibratedTariffComponents;
        }
        return defaultTariffComponents;
    }

    function enhanceHenrikPrice(eurPerMWh, eurRate, components = null) {
        if (!components) {
            components = getTariffComponents();
        }
        
        try {
            const spotPriceKrKwh = (eurPerMWh / 1000) * eurRate;
            
            let totalPrice = spotPriceKrKwh;
            totalPrice += components.elafgift;
            totalPrice += components.nettarif;
            totalPrice += components.systemtarif;
            totalPrice += components.spottillaeg;
            
            if (components.momsRate > 1.0) {
                totalPrice *= components.momsRate;
            }
            
            return Math.max(0, totalPrice);
            
        } catch (error) {
